{% extends 'base.html' %}
{% load dict_extras %}

{% block title %}Historical Data Analysis - OpenTracker{% endblock %}

{% block content %}
<div class="historical-container">
    <!-- Page Header -->
    <div class="historical-header">
        <div class="header-content">
            <h1 class="historical-title">
                <i class="header-icon">üìä</i>
                Historical Data Analysis
            </h1>
            <p class="historical-subtitle">Analyze sensor data over time periods</p>
        </div>
    </div>
    
    {% if messages %}
        {% for message in messages %}
            <div class="alert alert-{{ message.tags }}">
                {{ message }}
            </div>
        {% endfor %}
    {% endif %}

    <!-- Filter Form -->
    <div class="filter-section">
        <div class="section-header">
            <h3>Data Filters</h3>
            <p>Select date range, device, and data type to analyze</p>
        </div>
        
        <form method="post" class="filter-form">
            {% csrf_token %}
            <div class="filter-grid">
                <div class="form-group">
                    <label for="device_select">Device:</label>
                    <select name="device_id" id="device_select">
                        <option value="">All Devices</option>
                        {% for device in devices %}
                        <option value="{{ device.id }}" {% if selected_device and selected_device.id == device.id %}selected{% endif %}>
                            {{ device.name }} ({{ device.device_id }}) - {{ device.get_device_type_display }}
                        </option>
                        {% endfor %}
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="start_date">Start Date & Time:</label>
                    <input type="datetime-local" name="start_date" id="start_date" value="{{ start_date }}">
                </div>
                
                <div class="form-group">
                    <label for="end_date">End Date & Time:</label>
                    <input type="datetime-local" name="end_date" id="end_date" value="{{ end_date }}">
                </div>
                
                <div class="form-group">
                    <label for="data_type_filter">Data Type:</label>
                    <select name="data_type_filter" id="data_type_filter">
                        <option value="">All Types</option>
                        <option value="temperature" {% if data_type_filter == 'temperature' %}selected{% endif %}>Temperature</option>
                        <option value="humidity" {% if data_type_filter == 'humidity' %}selected{% endif %}>Humidity</option>
                        <option value="location" {% if data_type_filter == 'location' %}selected{% endif %}>Location</option>
                        <option value="speed" {% if data_type_filter == 'speed' %}selected{% endif %}>Speed</option>
                        <option value="ignition" {% if data_type_filter == 'ignition' %}selected{% endif %}>Ignition</option>
                    </select>
                </div>
            </div>
            
            <div class="filter-actions">
                <button type="submit" class="btn-primary">
                    üîç Analyze Data
                </button>
                <button type="button" class="btn-secondary" onclick="resetFilters()">
                    üîÑ Reset Filters
                </button>
            </div>
        </form>
    </div>

    <!-- Data Visualization Section -->
    {% if table_data %}
    <div class="visualization-section">
        <div class="section-header">
            <h3>üìà Data Visualization</h3>
        </div>

        <div class="chart-container">
            <canvas id="dataChart"></canvas>
        </div>

        <div class="chart-info">
            <p id="chartMessage">Chart will appear here after analyzing data</p>
        </div>

        <div class="chart-controls">
            <label for="chartPointsLimit" style="font-weight: 500; color: #374151;">Show last:</label>
            <select id="chartPointsLimit" onchange="updateChart()" style="padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 6px; margin-left: 8px;">
                <option value="20">20 time points</option>
                <option value="50">50 time points</option>
                <option value="100" selected>100 time points</option>
                <option value="500">500 time points</option>
                <option value="0">All time points</option>
            </select>
        </div>
    </div>

    <!-- Embed full dataset for chart (not just paginated table data) -->
    <script id="chartDataSource" type="application/json">
    [
        {% for row in data_entries %}
        {
            "timestamp": "{{ row.timestamp|date:'d/m/y H:i:s' }}",
            "deviceName": "{{ row.device.name|escapejs }}",
            "deviceType": "{{ row.device.device_type }}",
            "dataType": "{{ row.data_type|escapejs }}",
            "value": {% if row.value is None %}null{% else %}{{ row.value }}{% endif %},
            "unit": "{{ row.unit|escapejs }}"
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ]
    </script>
    {% endif %}

    <!-- Dynamic Table View -->
    {% if table_data %}
    <div class="data-section">
        <div class="section-header">
            <h3>Historical Data Entries</h3>
            <div class="section-actions">
                <p>Showing {{ page_obj.start_index }} to {{ page_obj.end_index }} of {{ total_rows }} entries</p>
                <button type="button" class="btn-export" onclick="exportToExcel()">
                    üì• Export to CSV
                </button>
            </div>
        </div>
        
        <div class="data-table-container">
            <table class="data-table enhanced-table">
                <thead>
                    <tr>
                        <th class="timestamp-col">Time</th>
                        <th class="device-col">Device Name</th>
                        {% for column in table_columns %}
                        <th class="data-col">
                            <span class="column-header">
                                {% if column == 'speed' %}
                                    Speed (km/h)
                                {% else %}
                                    {{ column|title }}
                                {% endif %}
                            </span>
                        </th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for row in table_data %}
                    <tr class="device-row device-{{ row.device.device_type }}">
                        <td class="timestamp">{{ row.timestamp|date:"d/m/y H:i:s" }}</td>
                        <td class="device">
                            <span class="device-name">{{ row.device.name }}</span>
                        </td>
                        {% for column in table_columns %}
                        <td class="data-cell data-{{ column }}">
                            {% if row.data|get_item:column %}
                                <span class="data-value">{{ row.data|get_item:column }}</span>
                            {% else %}
                                <span class="no-data">-</span>
                            {% endif %}
                        </td>
                        {% endfor %}
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <!-- Pagination Controls -->
        <div class="pagination-container">
            <div class="pagination-size-control">
                <form method="get" class="pagination-size-form" id="per-page-form">
                    {% if selected_device %}
                        <input type="hidden" name="device_id" value="{{ selected_device.id }}">
                    {% endif %}
                    {% if start_date %}
                        <input type="hidden" name="start_date" value="{{ start_date }}">
                    {% endif %}
                    {% if end_date %}
                        <input type="hidden" name="end_date" value="{{ end_date }}">
                    {% endif %}
                    {% if data_type_filter %}
                        <input type="hidden" name="data_type_filter" value="{{ data_type_filter }}">
                    {% endif %}
                    <span class="page-info-text">Show:</span>
                    <select name="per_page" class="pagination-size-select" onchange="updatePagination(this.value)">
                        <option value="10" {% if per_page == 10 %}selected{% endif %}>10</option>
                        <option value="20" {% if per_page == 20 %}selected{% endif %}>20</option>
                        <option value="50" {% if per_page == 50 %}selected{% endif %}>50</option>
                        <option value="100" {% if per_page == 100 %}selected{% endif %}>100</option>
                    </select>
                    <span class="page-info-text">per page</span>
                </form>
            </div>

            {% if page_obj.has_other_pages %}
            <div class="pagination">
                {% if page_obj.has_previous %}
                    <a href="#" onclick="changePage(1); return false;" class="page-link">First</a>
                    <a href="#" onclick="changePage({{ page_obj.previous_page_number }}); return false;" class="page-link">Previous</a>
                {% endif %}

                <span class="page-info">
                    Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
                </span>

                {% if page_obj.has_next %}
                    <a href="#" onclick="changePage({{ page_obj.next_page_number }}); return false;" class="page-link">Next</a>
                    <a href="#" onclick="changePage({{ page_obj.paginator.num_pages }}); return false;" class="page-link">Last</a>
                {% endif %}
            </div>
            {% else %}
            <div class="pagination">
                <span class="page-info">({{ total_rows }} total entries)</span>
            </div>
            {% endif %}
        </div>
    </div>
    {% elif request.method == 'POST' %}
    <div class="empty-state">
        <div class="empty-icon">üì≠</div>
        <h3>No Data Found</h3>
        <p>No sensor data matches your selected criteria. Try adjusting your filters.</p>
    </div>
    {% else %}
    <div class="empty-state">
        <div class="empty-icon">üìä</div>
        <h3>Ready to Analyze</h3>
        <p>Select your filters above and click "Analyze Data" to view historical sensor data.</p>
    </div>
    {% endif %}
</div>

<style>
.historical-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

.historical-header {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
    border-radius: 16px;
    padding: 32px;
    margin-bottom: 32px;
    color: white;
}

.historical-title {
    margin: 0 0 8px 0;
    font-size: 2rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 12px;
}

.header-icon {
    font-size: 2.5rem;
}

.historical-subtitle {
    margin: 0;
    opacity: 0.9;
    font-size: 1.1rem;
}

.filter-section, .statistics-section, .data-section, .visualization-section {
    background: white;
    border-radius: 16px;
    padding: 32px;
    margin-bottom: 24px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
}

.section-header {
    margin-bottom: 20px;
}

.section-header h3 {
    color: #1f2937;
    margin-bottom: 0;
    font-size: 1.25rem;
    font-weight: 600;
}

.section-header p {
    color: #6b7280;
    margin: 0;
}

.chart-controls {
    margin-top: 16px;
    margin-bottom: 12px;
    padding: 12px;
    background: #f9fafb;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.filter-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 12px;
}

.form-group {
    display: flex;
    flex-direction: column;
}

.form-group label {
    margin-bottom: 8px;
    font-weight: 600;
    color: #374151;
}

.form-group select,
.form-group input {
    width: 100%;
    padding: 12px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    font-size: 14px;
    background: white;
}

.date-format-hint {
    font-size: 12px;
    color: #6b7280;
    font-style: italic;
    margin-top: 4px;
}

.filter-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
    align-items: center;
    margin-top: 12px;
    min-height: 44px;
}

.btn-primary,
.btn-secondary {
    padding: 0 32px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    font-size: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 44px;
    line-height: 1;
    box-sizing: border-box;
    margin: 0;
    text-decoration: none;
    border: 1px solid transparent;
    min-width: 160px;
    white-space: nowrap;
}

.btn-primary {
    background: #dc2626;
    color: white;
    border-color: #dc2626;
    transition: background 0.2s;
}

.btn-primary:hover {
    background: #b91c1c;
    border-color: #b91c1c;
}

.btn-secondary {
    background: #f8f9fa;
    color: #3c4043;
    border-color: #dadce0;
    transition: all 0.15s ease-in-out;
}

.btn-secondary:hover {
    background: #f1f3f4;
    border-color: #c0c0c0;
}

.btn-export {
    background: #059669;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
    font-size: 14px;
}

.btn-export:hover {
    background: #047857;
}

.section-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.section-actions p {
    margin: 0;
}

.stats-overview {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 32px;
}

.stat-card {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 24px;
    display: flex;
    align-items: center;
    gap: 16px;
}

.stat-icon {
    font-size: 2rem;
    opacity: 0.8;
}

.stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #1f2937;
    margin-bottom: 4px;
}

.stat-label {
    color: #6b7280;
    font-size: 0.9rem;
    font-weight: 600;
}

.stat-sub {
    color: #9ca3af;
    font-size: 0.75rem;
    margin-top: 2px;
}

.type-statistics {
    margin-top: 32px;
}

.type-statistics h4 {
    color: #1f2937;
    margin-bottom: 16px;
}

.type-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 16px;
}

.type-stat-card {
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 16px;
    background: #f9fafb;
}

.type-stat-card h5 {
    margin: 0 0 12px 0;
    color: #1f2937;
    font-size: 1rem;
}

.stat-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
}

.stat-item .stat-label {
    color: #6b7280;
    font-size: 0.875rem;
}

.stat-item .stat-value {
    color: #1f2937;
    font-weight: 500;
    font-size: 0.875rem;
}

.data-table-container {
    overflow-x: auto;
    border-radius: 8px;
    border: 1px solid #e5e7eb;
    max-height: 120vh;
    overflow-y: auto;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
}

.data-table th {
    background: #f9fafb;
    padding: 12px 16px;
    text-align: left;
    font-weight: 600;
    color: #374151;
    border-bottom: 1px solid #e5e7eb;
    position: sticky;
    top: 0;
    z-index: 10;
}

.data-table td {
    padding: 12px 16px;
    border-bottom: 1px solid #f3f4f6;
    vertical-align: top;
}

.data-table tr:hover {
    background: #f9fafb;
}

.enhanced-table th {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-right: 1px solid #dee2e6;
}

.enhanced-table .timestamp-col {
    min-width: 140px;
    width: 140px;
}

.enhanced-table .device-col {
    min-width: 200px;
    width: 200px;
}

.enhanced-table .data-col {
    min-width: 120px;
    text-align: center;
}

.column-header {
    font-weight: 600;
    color: #374151;
}

.device-row.device-vehicle {
    border-left: 4px solid #dc2626;
}

.device-row.device-temperature-sensor {
    border-left: 4px solid #2563eb;
}

.device-row.device-sensor {
    border-left: 4px solid #059669;
}

.timestamp {
    font-family: monospace;
    color: #6b7280;
    white-space: nowrap;
    font-size: 0.85rem;
}

.device-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.device-name {
    font-weight: 600;
    color: #1f2937;
    font-size: 0.95rem;
}

.device-details {
    display: flex;
    align-items: center;
    gap: 8px;
}

.device-id {
    font-size: 0.75rem;
    color: #9ca3af;
    font-family: monospace;
}

.device-type-badge {
    font-size: 0.7rem;
    background: #e5e7eb;
    color: #374151;
    padding: 2px 6px;
    border-radius: 8px;
    text-transform: uppercase;
    font-weight: 500;
}

.data-cell {
    text-align: center;
}

.data-value {
    font-weight: 500;
    color: #1f2937;
    font-size: 0.9rem;
}

.no-data {
    color: #9ca3af;
    font-style: italic;
}

.data-ignition .data-value {
    color: #dc2626;
    font-weight: 600;
}

.data-speed .data-value {
    color: #2563eb;
    font-weight: 600;
}

.data-location .data-value {
    color: #059669;
    font-weight: 500;
}

.data-temperature .data-value {
    color: #d97706;
    font-weight: 500;
}

.data-humidity .data-value {
    color: #2563eb;
    font-weight: 500;
}

.type-badge {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
}

.type-temperature { background: #fef3c7; color: #d97706; }
.type-humidity { background: #dbeafe; color: #2563eb; }
.type-location { background: #d1fae5; color: #059669; }
.type-speed { background: #fce7f3; color: #be185d; }
.type-ignition { background: #e0e7ff; color: #4338ca; }

.value {
    font-weight: 500;
    color: #1f2937;
}

.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: #6b7280;
}

.empty-icon {
    font-size: 4rem;
    margin-bottom: 16px;
}

.empty-state h3 {
    color: #374151;
    margin-bottom: 8px;
}

.alert {
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 20px;
}

.alert-success {
    background: #d1fae5;
    color: #065f46;
    border: 1px solid #a7f3d0;
}

.alert-error {
    background: #fee2e2;
    color: #991b1b;
    border: 1px solid #fecaca;
}

/* Chart visualization styles */
.chart-container {
    position: relative;
    height: 400px;
    margin-bottom: 16px;
}

.chart-info {
    text-align: center;
    color: #6b7280;
    font-size: 14px;
    padding: 12px;
    background: #f9fafb;
    border-radius: 8px;
    margin-top: 12px;
}

.chart-info p {
    margin: 0;
}

/* Pagination styles */
.pagination-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    background: white;
    border-top: 1px solid #e5e7eb;
    border-radius: 0 0 16px 16px;
}

.pagination {
    display: flex;
    align-items: center;
    gap: 10px;
}

.pagination-size-control {
    display: flex;
    align-items: center;
    gap: 8px;
}

.pagination-size-form {
    display: flex;
    align-items: center;
    gap: 6px;
}

.page-info-text {
    color: #6b7280;
    font-size: 14px;
    font-weight: 500;
    margin: 0 4px;
}

.pagination-size-select {
    padding: 6px 10px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
    background: white;
    cursor: pointer;
    transition: all 0.2s;
}

.pagination-size-select:hover {
    border-color: #9ca3af;
}

.pagination-size-select:focus {
    outline: none;
    border-color: #dc2626;
    box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.1);
}

.page-link {
    padding: 6px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    color: #374151;
    text-decoration: none;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;
    background: white;
}

.page-link:hover {
    background: #f9fafb;
    border-color: #9ca3af;
    color: #1f2937;
}

.page-info {
    color: #6b7280;
    font-size: 14px;
    padding: 0 12px;
}

@media (max-width: 768px) {
    .filter-grid {
        grid-template-columns: 1fr;
    }

    .filter-actions {
        flex-direction: column;
    }

    .stats-overview {
        grid-template-columns: 1fr;
    }

    .type-stats-grid {
        grid-template-columns: 1fr;
    }

    .group-header {
        flex-direction: column;
        align-items: flex-start;
    }

    .group-data {
        padding: 16px;
    }

    .pagination-container {
        flex-direction: column;
        gap: 15px;
    }

    .pagination {
        flex-wrap: wrap;
        justify-content: center;
    }
}
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
function resetFilters() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    
    // Reset all filters and set today's date
    document.getElementById('device_select').value = '';
    document.getElementById('start_date').value = `${year}-${month}-${day}T00:00`;
    document.getElementById('end_date').value = `${year}-${month}-${day}T23:59`;
    document.getElementById('data_type_filter').value = '';
}

function exportToExcel() {
    // Get current filter values
    const form = document.querySelector('.filter-form');
    const formData = new FormData(form);

    // Add export parameter
    formData.append('export', 'excel');

    // Create a form and submit it to trigger download
    const exportForm = document.createElement('form');
    exportForm.method = 'POST';
    exportForm.action = window.location.pathname;
    exportForm.style.display = 'none';

    // Add all form data as hidden inputs
    for (let [key, value] of formData.entries()) {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = key;
        input.value = value;
        exportForm.appendChild(input);
    }

    document.body.appendChild(exportForm);
    exportForm.submit();
    document.body.removeChild(exportForm);
}

// Pagination functions
function changePage(pageNumber) {
    // Get the current filter form
    const filterForm = document.querySelector('.filter-form');
    const formData = new FormData(filterForm);

    // Get per_page value
    const perPageSelect = document.querySelector('.pagination-size-select');
    const perPage = perPageSelect ? perPageSelect.value : '20';

    // Create a new form for navigation
    const navForm = document.createElement('form');
    navForm.method = 'POST';
    navForm.action = window.location.pathname;
    navForm.style.display = 'none';

    // Add all filter data
    for (let [key, value] of formData.entries()) {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = key;
        input.value = value;
        navForm.appendChild(input);
    }

    // Add pagination parameters
    const pageInput = document.createElement('input');
    pageInput.type = 'hidden';
    pageInput.name = 'page';
    pageInput.value = pageNumber;
    navForm.appendChild(pageInput);

    const perPageInput = document.createElement('input');
    perPageInput.type = 'hidden';
    perPageInput.name = 'per_page';
    perPageInput.value = perPage;
    navForm.appendChild(perPageInput);

    // Submit the form
    document.body.appendChild(navForm);
    navForm.submit();
}

function updatePagination(perPageValue) {
    // Get the current filter form
    const filterForm = document.querySelector('.filter-form');
    const formData = new FormData(filterForm);

    // Create a new form for navigation
    const navForm = document.createElement('form');
    navForm.method = 'POST';
    navForm.action = window.location.pathname;
    navForm.style.display = 'none';

    // Add all filter data
    for (let [key, value] of formData.entries()) {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = key;
        input.value = value;
        navForm.appendChild(input);
    }

    // Add per_page parameter
    const perPageInput = document.createElement('input');
    perPageInput.type = 'hidden';
    perPageInput.name = 'per_page';
    perPageInput.value = perPageValue;
    navForm.appendChild(perPageInput);

    // Reset to page 1 when changing per_page
    const pageInput = document.createElement('input');
    pageInput.type = 'hidden';
    pageInput.name = 'page';
    pageInput.value = '1';
    navForm.appendChild(pageInput);

    // Submit the form
    document.body.appendChild(navForm);
    navForm.submit();
}

// Chart visualization functions
let dataChart = null;

function updateChart() {
    createChart();
}

function createChart() {
    const canvas = document.getElementById('dataChart');
    console.log('createChart called, canvas:', canvas);

    if (!canvas) {
        console.log('Canvas not found');
        return;
    }

    const ctx = canvas.getContext('2d');

    // Prepare data from the table
    const chartData = prepareChartData();
    console.log('Chart data prepared:', chartData);

    if (!chartData || chartData.datasets.length === 0) {
        const msg = 'No chartable data found. Ensure you have numeric data (temperature, speed, humidity, etc.) in the table.';
        document.getElementById('chartMessage').textContent = msg;
        console.log(msg);
        return;
    }

    // Destroy existing chart if any
    if (dataChart) {
        dataChart.destroy();
    }

    console.log('Chart Y-axis config:', {
        label: chartData.yAxisLabel,
        min: chartData.yAxisMin,
        max: chartData.yAxisMax
    });

    // Create new chart
    dataChart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        padding: 15,
                        font: {
                            size: 13,
                            weight: '500'
                        },
                        usePointStyle: true,
                        pointStyle: 'circle',
                        boxWidth: 8,
                        boxHeight: 8
                    },
                    onClick: function(e, legendItem, legend) {
                        const index = legendItem.datasetIndex;
                        const chart = legend.chart;
                        const meta = chart.getDatasetMeta(index);

                        // Toggle visibility
                        meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                        chart.update();
                    }
                },
                title: {
                    display: true,
                    text: chartData.title || 'Data Over Time',
                    font: {
                        size: 16,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                const dataType = context.dataset.label.toLowerCase();
                                const isOnOff = context.dataset.isOnOff;

                                // For ON/OFF signals, show ON/OFF instead of numeric value
                                if (isOnOff) {
                                    // If normalized, check against the normalized range
                                    const normalizedRange = chartData.normalizedRange;
                                    if (chartData.needsNormalization && normalizedRange) {
                                        const midPoint = (normalizedRange.min + normalizedRange.max) / 2;
                                        label += context.parsed.y > midPoint ? 'ON' : 'OFF';
                                    } else {
                                        // Not normalized, simple 0/1 check
                                        label += context.parsed.y > 0.5 ? 'ON' : 'OFF';
                                    }
                                } else {
                                    // Numeric signal - show value with appropriate unit
                                    const value = context.parsed.y;
                                    label += value.toFixed(2);

                                    // Add unit based on data type
                                    if (dataType.includes('speed')) {
                                        label += ' km/h';
                                    } else if (dataType.includes('temperature')) {
                                        label += ' ¬∞C';
                                    } else if (dataType.includes('humidity')) {
                                        label += ' %';
                                    }
                                }
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Time'
                    },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        maxTicksLimit: 12,
                        callback: function(value, index, ticks) {
                            // Get the label (timestamp)
                            const label = this.getLabelForValue(value);
                            // Extract just the time part (HH:MM:SS)
                            if (label && label.includes(' ')) {
                                return label.split(' ')[1]; // Return only time part
                            }
                            return label;
                        }
                    }
                },
                y: {
                    display: true,
                    title: {
                        display: true,
                        text: chartData.yAxisLabel || 'Value'
                    },
                    beginAtZero: chartData.yAxisMin !== undefined ? chartData.yAxisMin === 0 : true,
                    ticks: {
                        callback: function(value, index, ticks) {
                            // For pure ON/OFF signals (not normalized), show ON/OFF labels
                            if (chartData.hasOnOff && !chartData.hasNumeric) {
                                if (value === 1) return 'ON';
                                if (value === 0) return 'OFF';
                                return '';
                            }
                            // For mixed or numeric signals, show numeric values
                            return value.toFixed(1);
                        },
                        stepSize: (chartData.hasOnOff && !chartData.hasNumeric) ? 1 : undefined
                    },
                    min: chartData.yAxisMin,
                    max: chartData.yAxisMax,
                    grace: chartData.yAxisMin !== undefined ? 0 : '5%'  // No padding if explicit range set
                }
            },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            }
        }
    });

    let chartInfo = `Showing ${chartData.datasets.length} data series with ${chartData.labels.length} time points`;
    if (chartData.needsNormalization) {
        chartInfo += `<br><small style="color: #9ca3af;">‚ÑπÔ∏è ON/OFF signals are normalized to match numeric data range</small>`;
    }
    chartInfo += `<br><small style="color: #9ca3af;">üí° Tip: Click legend items to hide/show signals</small>`;
    document.getElementById('chartMessage').innerHTML = chartInfo;
}

function prepareChartData() {
    // Get the point limit from dropdown
    const pointLimit = parseInt(document.getElementById('chartPointsLimit')?.value || '100');
    console.log('Point limit selected:', pointLimit);

    // Get full dataset from embedded JSON
    const dataSourceElement = document.getElementById('chartDataSource');
    if (!dataSourceElement) {
        console.log('Chart data source not found');
        return null;
    }

    let dataPoints = [];
    try {
        dataPoints = JSON.parse(dataSourceElement.textContent);
    } catch (e) {
        console.error('Failed to parse chart data:', e);
        return null;
    }

    if (dataPoints.length === 0) {
        return null;
    }

    console.log('Total data points from server:', dataPoints.length);

    // Filter out invalid data points (but keep 0 values for things like ignition)
    dataPoints = dataPoints.filter(point => {
        return point.value !== null && point.value !== '' && !isNaN(parseFloat(point.value));
    });

    console.log('After filtering invalid:', dataPoints.length);

    if (dataPoints.length === 0) {
        return null;
    }

    // Sort by timestamp to ensure chronological order (oldest to newest)
    dataPoints.sort((a, b) => {
        // Parse DD/MM/YY HH:MM:SS format for sorting
        const parseTimestamp = (ts) => {
            const [datePart, timePart] = ts.split(' ');
            const [day, month, year] = datePart.split('/');
            const fullYear = year.length === 2 ? '20' + year : year;
            return new Date(`${fullYear}-${month}-${day}T${timePart}`).getTime();
        };
        return parseTimestamp(a.timestamp) - parseTimestamp(b.timestamp);
    });

    console.log('Data range: from', dataPoints[0].timestamp, 'to', dataPoints[dataPoints.length - 1].timestamp);

    // Get unique timestamps in chronological order
    const uniqueTimestamps = [...new Set(dataPoints.map(p => p.timestamp))];
    console.log('Total unique timestamps:', uniqueTimestamps.length);

    // Apply point limit: take LAST N timestamps (most recent data)
    let selectedTimestamps = uniqueTimestamps;
    if (pointLimit > 0 && uniqueTimestamps.length > pointLimit) {
        selectedTimestamps = uniqueTimestamps.slice(-pointLimit);
        console.log('Taking LAST', pointLimit, 'time points from', selectedTimestamps[0], 'to', selectedTimestamps[selectedTimestamps.length - 1]);
    } else {
        console.log('Showing all', uniqueTimestamps.length, 'time points');
    }

    // Keep only data points that match the selected timestamps
    const limitedDataPoints = dataPoints.filter(p => selectedTimestamps.includes(p.timestamp));
    console.log('Showing:', selectedTimestamps.length, 'time points with', limitedDataPoints.length, 'total sensor readings');

    // Group by device and data type
    const seriesMap = {};

    limitedDataPoints.forEach(point => {
        const seriesKey = `${point.deviceName} - ${point.dataType}`;
        if (!seriesMap[seriesKey]) {
            seriesMap[seriesKey] = {
                label: seriesKey,
                data: [],
                deviceType: point.deviceType,
                dataType: point.dataType,
                rawData: []  // Store original values for ignition
            };
        }

        // Parse value as number
        let numValue = parseFloat(point.value);

        // For ignition and other ON/OFF signals, normalize to 0 or 1
        const isOnOffSignal = point.dataType.toLowerCase() === 'ignition' ||
                             point.dataType.toLowerCase().includes('status') ||
                             point.dataType.toLowerCase().includes('state');

        if (isOnOffSignal) {
            const originalValue = numValue;
            numValue = numValue > 0 ? 1 : 0;
            seriesMap[seriesKey].rawData.push(numValue);  // Store 0 or 1

            // Debug logging for first few points
            if (seriesMap[seriesKey].data.length < 5) {
                console.log(`${point.dataType} raw: ${originalValue} -> normalized: ${numValue}`);
            }
        }

        seriesMap[seriesKey].data.push({
            x: point.timestamp,
            y: numValue,
            isOnOff: isOnOffSignal,
            rawValue: isOnOffSignal ? numValue : undefined  // Store original 0/1
        });
    });

    // Get unique timestamps for chart labels
    const allTimestamps = limitedDataPoints.map(p => p.timestamp);
    const labels = [...new Set(allTimestamps)];

    // Identify signal types
    const onOffSeries = Object.values(seriesMap).filter(s =>
        s.dataType.toLowerCase() === 'ignition' ||
        s.dataType.toLowerCase().includes('status') ||
        s.dataType.toLowerCase().includes('state')
    );
    const numericSeries = Object.values(seriesMap).filter(s =>
        s.dataType.toLowerCase() !== 'ignition' &&
        !s.dataType.toLowerCase().includes('status') &&
        !s.dataType.toLowerCase().includes('state')
    );

    const hasOnOff = onOffSeries.length > 0;
    const hasNumeric = numericSeries.length > 0;
    const needsNormalization = hasOnOff && hasNumeric;

    console.log(`Chart has ${onOffSeries.length} ON/OFF signals and ${numericSeries.length} numeric signals`);

    // Calculate Y-axis range from numeric data
    let yMin = 0;
    let yMax = 100;

    if (hasNumeric) {
        const numericValues = [];
        numericSeries.forEach(series => {
            series.data.forEach(d => numericValues.push(d.y));
        });

        if (numericValues.length > 0) {
            yMin = Math.min(...numericValues);
            yMax = Math.max(...numericValues);

            // Add 5% padding for better visualization
            const range = yMax - yMin;
            if (range > 0) {
                yMin = yMin - range * 0.05;
                yMax = yMax + range * 0.05;
            }
        }
    } else if (hasOnOff) {
        // Only ON/OFF signals, use 0-1 range
        yMin = 0;
        yMax = 1;
    }

    console.log(`Y-axis range: ${yMin} to ${yMax}`);

    if (needsNormalization) {
        console.log(`Normalizing ON/OFF signals: OFF -> ${yMin}, ON -> ${yMax}`);

        // Count ON/OFF occurrences for debugging
        onOffSeries.forEach(series => {
            const offCount = series.data.filter(d => d.y === 0).length;
            const onCount = series.data.filter(d => d.y === 1).length;
            console.log(`${series.label}: ${offCount} OFF, ${onCount} ON`);
        });
    }

    // Define a color palette for different series
    const colorPalette = [
        '#dc2626', // Red
        '#2563eb', // Blue
        '#059669', // Green
        '#d97706', // Orange
        '#7c3aed', // Purple
        '#db2777', // Pink
        '#0891b2', // Cyan
        '#65a30d', // Lime
        '#c026d3', // Magenta
        '#ea580c', // Deep Orange
    ];

    const datasets = Object.values(seriesMap).map((series, index) => {
        // Assign unique color to each series
        const color = colorPalette[index % colorPalette.length];

        const isOnOffSignal = series.dataType.toLowerCase() === 'ignition' ||
                             series.dataType.toLowerCase().includes('status') ||
                             series.dataType.toLowerCase().includes('state');

        // Create data array aligned with labels
        let mappingCount = 0;  // Track for debug logging
        const alignedData = labels.map(label => {
            const dataPoint = series.data.find(d => d.x === label);
            if (!dataPoint) return null;

            let value = dataPoint.y;

            // Normalize ON/OFF signals to match numeric data range
            if (isOnOffSignal && needsNormalization) {
                // Map 0 -> yMin, 1 -> yMax
                // Use strict comparison since we normalized to exactly 0 or 1 earlier
                const originalOnOff = value;  // This is 0 or 1
                value = (originalOnOff === 0) ? yMin : yMax;

                // Debug first few mappings
                if (mappingCount < 3) {
                    console.log(`Mapping ${series.label}: ${originalOnOff} -> ${value} (yMin=${yMin}, yMax=${yMax})`);
                    mappingCount++;
                }
            }

            return value;
        });

        return {
            label: series.label,
            data: alignedData,
            borderColor: color,
            backgroundColor: color + '20', // Add transparency
            borderWidth: isOnOffSignal ? 3 : 2,  // Thicker line for ON/OFF signals
            pointRadius: isOnOffSignal ? 0 : 3,  // No points for ON/OFF (looks cleaner as step)
            pointHoverRadius: 5,
            tension: isOnOffSignal ? 0 : 0.1,  // No smoothing for ON/OFF (sharp transitions)
            stepped: isOnOffSignal ? 'before' : false,  // Step function for ON/OFF signals
            spanGaps: true,
            yAxisID: 'y',
            isOnOff: isOnOffSignal  // Store for tooltip handling
        };
    });

    // Determine chart title and Y-axis label
    const uniqueDataTypes = [...new Set(Object.values(seriesMap).map(s => s.dataType))];
    let title = 'Sensor Data Over Time';
    let yAxisLabel = 'Value';
    let explicitYMin = undefined;
    let explicitYMax = undefined;

    if (uniqueDataTypes.length === 1) {
        const dataType = uniqueDataTypes[0];
        const dataTypeLower = dataType.toLowerCase();

        title = `${dataType} Over Time`;

        if (dataTypeLower.includes('speed')) {
            yAxisLabel = 'Speed (km/h)';
        } else if (dataTypeLower.includes('temperature')) {
            yAxisLabel = 'Temperature (¬∞C)';
        } else if (dataTypeLower.includes('humidity')) {
            yAxisLabel = 'Humidity (%)';
        } else if (dataTypeLower === 'ignition' || dataTypeLower.includes('status')) {
            yAxisLabel = 'Status';
        } else {
            yAxisLabel = dataType;
        }
    } else {
        // Multiple data types
        title = 'Multi-Sensor Data Over Time';
        yAxisLabel = 'Value';
    }

    // Set Y-axis range
    if (hasOnOff && !hasNumeric) {
        // Only ON/OFF signals
        explicitYMin = 0;
        explicitYMax = 1;
    } else if (needsNormalization) {
        // Mixed signals - use calculated numeric range
        explicitYMin = yMin;
        explicitYMax = yMax;
    }
    // Otherwise let Chart.js auto-scale

    console.log('Chart config:', {
        title,
        yAxisLabel,
        yMin: explicitYMin,
        yMax: explicitYMax,
        needsNormalization
    });

    // Final debug: Show a sample of the actual chart data
    console.log('=== FINAL CHART DATA SAMPLE ===');
    datasets.forEach((ds, idx) => {
        if (idx < 3) {  // Only show first 3 series
            const nonNullData = ds.data.filter(v => v !== null);
            const sampleValues = nonNullData.slice(0, 5);
            console.log(`${ds.label}:`, {
                isOnOff: ds.isOnOff,
                sampleValues,
                min: Math.min(...nonNullData),
                max: Math.max(...nonNullData),
                count: nonNullData.length
            });
        }
    });

    return {
        labels,
        datasets,
        title,
        yAxisLabel,
        yAxisMin: explicitYMin,
        yAxisMax: explicitYMax,
        hasOnOff,
        hasNumeric,
        needsNormalization,
        normalizedRange: { min: yMin, max: yMax }
    };
}

// Initialize chart when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Existing date initialization code...
    const startDate = document.getElementById('start_date');
    const endDate = document.getElementById('end_date');

    // Set default dates for today if no values are set (first time visiting page)
    if (!startDate.value && !endDate.value) {
        const now = new Date();

        // Get current date components
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');

        // Format for datetime-local input (YYYY-MM-DDTHH:mm)
        const startDateTime = `${year}-${month}-${day}T00:00`;
        const endDateTime = `${year}-${month}-${day}T23:59`;

        startDate.value = startDateTime;
        endDate.value = endDateTime;

        console.log('Default dates set (DD/MM/YYYY):', `${day}/${month}/${year}`, 'to', `${day}/${month}/${year}`);
    }

    // Add helpful tooltips for date format
    startDate.title = 'Select date and time in DD/MM/YYYY HH:MM format';
    endDate.title = 'Select date and time in DD/MM/YYYY HH:MM format';

    // Create chart if data is present
    if (document.getElementById('dataChart')) {
        console.log('Chart.js loaded:', typeof Chart !== 'undefined');
        if (typeof Chart !== 'undefined') {
            setTimeout(createChart, 100); // Small delay to ensure table is fully rendered
        } else {
            console.error('Chart.js library not loaded!');
            document.getElementById('chartMessage').textContent = 'Chart library failed to load. Please refresh the page.';
        }
    }
});
</script>
{% endblock %}